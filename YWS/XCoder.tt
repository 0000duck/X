<#@ template language="C#" hostSpecific="true" debug="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml" #>
<#@ output extension=".log" #>
<#
	// 尽管T4模版可以直接调用XCoder内部类库进行代码生成，但是那会导致XCoder文件被锁定，所以采用启动进程来生成的方式！

	// 取得模版所在目录
	var mypath = Path.GetDirectoryName(Host.TemplateFile) + "\\";
	var mdl = mypath + "YWS.xml";	// 数据模型文件

	// 计算数据模型工具XCoder位置
	var xpath = GetXPath(mypath);
	
	var exe = xpath + "XCoder.exe";
	var cfg = mypath + "set.config";
	var arg = String.Format("-Render -model \"{0}\" -config \"{1}\"", mdl, cfg);
	WriteLine("路径：" + exe);
	WriteLine("参数：" + arg);

	var dic = new Dictionary<String, Object>();
	dic["NameSpace"] = "NewLife.Ab";// 命名空间
	dic["EntityConnName"] = "Ab";	// 连接名
	
	dic["BaseClass"] = "Entity";	// 实体基类
	dic["RenderGenEntity"] = false;	// 生成泛型实体类
	dic["OutputPath"] = "";			// 输出目录
	dic["Override"] = true;			// 是否覆盖目标文件
	dic["UseCNFileName"] = true;	// 中文文件名
	dic["UseHeadTemplate"] = true;	// 使用.cs文件头模版
	// 文件头模版
	dic["HeadTemplate"] = "/*\r\n * XCoder v&lt;#=Version#&gt;\r\n * 作者：&lt;#=Environment.UserName + \"/\" + Environment.MachineName#&gt;\r\n * 时间：&lt;#=DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\")#&gt;\r\n * 版权：版权所有 (C) 新生命开发团队 &lt;#=DateTime.Now.ToString(\"yyyy\")#&gt;\r\n*/";

	dic["TemplateName"] = "[内置]数据字典";		// 模版名
	Save(cfg, dic);
	WriteLine("生成：" + dic["TemplateName"]);
	Process.Start(exe, arg);

	dic["TemplateName"] = "[内置]实体数据";		// 模版名
	Save(cfg, dic);
	WriteLine("生成：" + dic["TemplateName"]);
	Process.Start(exe, arg);

	dic["Override"] = false;		// 是否覆盖目标文件
	dic["TemplateName"] = "[内置]实体业务";		// 模版名
	Save(cfg, dic);
	WriteLine("生成：" + dic["TemplateName"]);
	Process.Start(exe, arg);

	dic["UseCNFileName"] = false;	// 中文文件名
	dic["TemplateName"] = "[内置]页面";			// 模版名
	Save(cfg, dic);
	WriteLine("生成：" + dic["TemplateName"]);
	Process.Start(exe, arg);
#>
<#+
	String GetXPath(String mypath)
	{
		var xpath = Path.Combine(mypath, @"XCoder\");
		if(!File.Exists(xpath + "XCoder.exe")) xpath = Path.Combine(mypath, @"..\XCoder\");
		if(!File.Exists(xpath + "XCoder.exe")) xpath = Path.Combine(mypath, @"..\代码生成\");
		if(!File.Exists(xpath + "XCoder.exe")) xpath = Path.Combine(mypath, @"..\..\XCoder\");
		if(!File.Exists(xpath + "XCoder.exe")) xpath = Path.Combine(mypath, @"..\..\代码生成\");
		if(!File.Exists(xpath + "XCoder.exe")) xpath = Path.Combine(mypath, @"C:\X\XCoder\");
		if(!File.Exists(xpath + "XCoder.exe")) xpath = Path.Combine(mypath, @"C:\X\代码生成\");
		if(!File.Exists(xpath + "XCoder.exe")) throw new Exception("无法定位数据模型工具XCoder的位置！");
		xpath = Path.GetFullPath(xpath);
		
		return xpath;
	}

	// 保存字典到Xml文件，其实是变相序列化
	void Save(String file, Dictionary<String, Object> data)
	{
		var doc = new XmlDocument();
		var root = doc.CreateElement("XConfig");
		doc.AppendChild(root);

		if (data != null && data.Count > 0)
		{
			foreach (var item in data)
			{
				var elm = doc.CreateElement(item.Key);
				elm.InnerText = item.Value + "";
				root.AppendChild(elm);
			}
		}
		
		File.WriteAllText(file, doc.OuterXml);
	}
#>