<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NewLife.Core</name>
    </assembly>
    <members>
        <member name="T:NewLife.Log.XTrace">
            <summary>
            日志类，包含跟踪调试功能
            </summary>
        </member>
        <member name="F:NewLife.Log.XTrace.isFirst">
            <summary>
            是否当前进程的第一次写日志
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.InitLog">
            <summary>
            初始化日志记录文件
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.CloseWriter(System.Object)">
            <summary>
            停止日志
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.PerformWriteLog(System.Object)">
            <summary>
            使用线程池线程异步执行日志写入动作
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String)">
            <summary>
            输出日志
            </summary>
            <param name="msg">信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.DebugStack">
            <summary>
            堆栈调试。
            输出堆栈信息，用于调试时处理调用上下文。
            本方法会造成大量日志，请慎用。
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.DebugStack(System.Int32)">
            <summary>
            堆栈调试。
            </summary>
            <param name="maxNum">最大捕获堆栈方法数</param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String,System.Object[])">
            <summary>
            写日志
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="P:NewLife.Log.XTrace.LogPath">
            <summary>
            日志目录
            </summary>
        </member>
        <member name="E:NewLife.Log.XTrace.OnWriteLog">
            <summary>
            写日志事件。绑定该事件后，XTrace将不再把日志写到日志文件中去。
            </summary>
        </member>
        <member name="P:NewLife.Log.XTrace.Debug">
            <summary>是否调试。如果代码指定了值，则只会使用代码指定的值，否则每次都读取配置。</summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolFormatterHead">
            <summary>
            协议序列化头部
            </summary>
            <remarks>
            默认情况下，协议序列化包含头部信息，记录着本次序列化的配置信息。
            使用特性来控制序列化过程优先级更高。
            </remarks>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatterHead.System#ICloneable#Clone">
            <summary>
            克隆
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatterHead.Clone">
            <summary>
            克隆
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatterHead.Magic">
            <summary>标识</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatterHead.Version">
            <summary>版本</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatterHead.FileVersion">
            <summary>文件版本</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatterHead.Config">
            <summary>配置信息</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatterHead.AssemblyName">
            <summary>汇编名</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatterHead.TypeName">
            <summary>类型名</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatterHead.Types">
            <summary>类型集合</summary>
            <remarks>支持序列化具体数据之前指定类型，存储的时候使用压缩编码的整数表示，也就是类型集合中的序号</remarks>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatterHead.RefObjects">
            <summary>引用对象集合</summary>
            <remarks>对于多次引用的对象，集中存储</remarks>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatterHead.Default">
            <summary>默认头部信息</summary>
        </member>
        <member name="T:NewLife.IO.BinaryReaderX">
            <summary>
            二进制协议读取器
            </summary>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.#ctor(System.IO.Stream)">
            <summary>
            构造
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadEncodedInt32">
            <summary>
            以压缩格式读取32位整数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadEncodedInt64">
            <summary>
            以压缩格式读取64位整数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadValue(System.Type,System.Boolean)">
            <summary>
            读取值类型数据
            </summary>
            <param name="type"></param>
            <param name="encodeInt"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.TryReadValue(System.Type,System.Boolean,System.Object@)">
            <summary>
            尝试读取值类型数据，返回是否读取成功
            </summary>
            <param name="type"></param>
            <param name="encodeInt"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadX(System.Type,System.Object@)">
            <summary>
            扩展读取，反射查找合适的读取方法
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadGuid">
            <summary>
            读取Guid
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadIPAddress">
            <summary>
            读取IPAddress
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadIPEndPoint">
            <summary>
            读取IPEndPoint
            </summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolNonSerializedAttribute">
            <summary>
            不序列化指定字段或属性
            </summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolAttribute">
            <summary>
            协议特性
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolAttribute.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolAttribute.#ctor(NewLife.Serialization.Protocol.ConfigFlags)">
            <summary>
            初始化
            </summary>
            <param name="flag"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolAttribute.MergeTo(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            特性设置合并到设置信息
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolAttribute.Equals(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            比较两个特性是否相等
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolAttribute.GetCustomAttributes``1(System.Reflection.MemberInfo)">
            <summary>
            获取自定义特性
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolAttribute.GetCustomAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            获取自定义特性
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolAttribute.Flag">
            <summary>序列化标识</summary>
        </member>
        <member name="T:NewLife.Messaging.MessageExceptionOption">
            <summary>
            消息异常选项
            </summary>
        </member>
        <member name="F:NewLife.Messaging.MessageExceptionOption.Ignore">
            <summary>
            忽略
            </summary>
        </member>
        <member name="F:NewLife.Messaging.MessageExceptionOption.Throw">
            <summary>
            抛出
            </summary>
        </member>
        <member name="F:NewLife.Messaging.MessageExceptionOption.SaveAsMessage">
            <summary>
            保存为异常消息
            </summary>
        </member>
        <member name="T:NewLife.DisposeBase">
            <summary>
            具有销毁资源处理的抽象基类
            </summary>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose(System.Boolean)">
            <summary>
            释放资源，参数表示是否由Dispose调用。该方法保证OnDispose只被调用一次！
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.DisposeBase.OnDispose(System.Boolean)">
            <summary>
            子类重载实现资源释放逻辑时必须首先调用基类方法
            </summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="M:NewLife.DisposeBase.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="P:NewLife.DisposeBase.Disposed">
            <summary>是否已经释放</summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolTest">
            <summary>
            测试
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolTest.Test">
            <summary>
            测试
            </summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolTest.Response">
            <summary>
            邀请响应
            </summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.IProtocolSerializable">
            <summary>
            自定义序列化接口
            </summary>
            <remarks>
            该接口支持多层实现，向下延伸，下层优先。
            某个类实现该接口后，该类的所有属性，以及所有子孙类属性都将有效
            </remarks>
        </member>
        <member name="M:NewLife.Serialization.Protocol.IProtocolSerializable.OnSerializing(NewLife.Serialization.Protocol.WriteContext)">
            <summary>
            序列化前触发
            </summary>
            <param name="context"></param>
            <returns>是否允许序列化当前字段或属性</returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.IProtocolSerializable.OnSerialized(NewLife.Serialization.Protocol.WriteContext)">
            <summary>
            序列化后触发
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.IProtocolSerializable.OnDeserializing(NewLife.Serialization.Protocol.ReadContext)">
            <summary>
            反序列化前触发
            </summary>
            <param name="context"></param>
            <returns>是否允许反序列化当前字段或属性</returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.IProtocolSerializable.OnDeserialized(NewLife.Serialization.Protocol.ReadContext)">
            <summary>
            反序列化后触发
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.IProtocolSerializable.OnCreateInstance(NewLife.Serialization.Protocol.ReadContext,System.Type)">
            <summary>
            为指定类型创建实例时触发
            </summary>
            <param name="context"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTest.Response.iii">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTest.Response.i64">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTest.Response.time">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTest.Response.Str">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTest.Response.Private">
            <summary>对方的私有地址</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTest.Response.Public">
            <summary>我的共有地址</summary>
        </member>
        <member name="T:NewLife.Serialization.OnProtocolCreateInstanceAttribute">
            <summary>
            创建实例时调用的方法
            </summary>
        </member>
        <member name="T:NewLife.Serialization.OnProtocolDeserializedAttribute">
            <summary>
            反序列化后执行该方法
            </summary>
        </member>
        <member name="T:NewLife.Serialization.OnProtocolDeserializingAttribute">
            <summary>
            反序列化前执行该方法
            </summary>
        </member>
        <member name="T:NewLife.Serialization.OnProtocolSerializedAttribute">
            <summary>
            序列化后执行该方法
            </summary>
        </member>
        <member name="T:NewLife.Serialization.OnProtocolSerializingAttribute">
            <summary>
            序列化前执行该方法
            </summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.FormatterConfig">
            <summary>
            协议序列化配置
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.FormatterConfig.GetFlag(NewLife.Serialization.Protocol.ConfigFlags)">
            <summary>
            获取标识位
            </summary>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.FormatterConfig.SetFlag(NewLife.Serialization.Protocol.ConfigFlags,System.Boolean)">
            <summary>
            设置标识位
            </summary>
            <param name="flag"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.FormatterConfig.System#ICloneable#Clone">
            <summary>
            克隆
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.FormatterConfig.Clone">
            <summary>
            克隆
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.FormatterConfig.Merge(NewLife.Serialization.Protocol.ProtocolAttribute[])">
            <summary>
            合并特性
            </summary>
            <param name="atts"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.FormatterConfig.CloneAndMerge(System.Reflection.MemberInfo)">
            <summary>
            克隆自身，合并指定成员的协议特性
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.FormatterConfig.IsSystemType(System.Type)">
            <summary>
            是否系统类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.FormatterConfig.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.FormatterConfig.Size">
            <summary>大小</summary>
            <remarks>默认为0时，首先序列化一个压缩整数作为数组元素个数，再序列化每一个项；设置了大小后，不再压缩元素个数，而是以特性指定的大小为准</remarks>
        </member>
        <member name="P:NewLife.Serialization.Protocol.FormatterConfig.Flag">
            <summary>标识</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.FormatterConfig.NoHead">
            <summary>
            是否没有头部
            </summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.FormatterConfig.SerialProperty">
            <summary>是否仅序列化属性</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.FormatterConfig.NotNull">
            <summary>
            是否非空
            </summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.FormatterConfig.EncodeInt">
            <summary>
            是否压缩整数
            </summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.FormatterConfig.UseRefObject">
            <summary>是否使用对象引用</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.FormatterConfig.Default">
            <summary>默认配置信息</summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolSerializingEventArgs">
            <summary>
            协议序列化事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolSerializingEventArgs.#ctor(NewLife.Serialization.Protocol.WriteContext)">
            <summary>
            构造
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolSerializingEventArgs.Context">
            <summary>上下文</summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolCreateInstanceEventArgs">
            <summary>
            创建实例触发事件参数
            </summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolCreateInstanceEventArgs.Context">
            <summary>上下文</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolCreateInstanceEventArgs.Type">
            <summary>要创建实例的类型</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolCreateInstanceEventArgs.Obj">
            <summary>创建的对象</summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ConfigFlags">
            <summary>
            序列化标识
            </summary>
        </member>
        <member name="F:NewLife.Serialization.Protocol.ConfigFlags.NoHead">
            <summary>
            没有头部
            </summary>
            <remarks>
            没有头部的序列化只能采用默认配置
            </remarks>
        </member>
        <member name="F:NewLife.Serialization.Protocol.ConfigFlags.SerialProperty">
            <summary>
            序列化属性
            </summary>
            <remarks>
            默认情况下只序列化字段，但是由特性控制的是否序列化优先级更高，该标识仅对没有任何特性的字段或属性有效
            </remarks>
        </member>
        <member name="F:NewLife.Serialization.Protocol.ConfigFlags.EncodeInt">
            <summary>
            压缩整数
            </summary>
            <remarks>
            使用压缩编码的整数，更节省空间
            </remarks>
        </member>
        <member name="F:NewLife.Serialization.Protocol.ConfigFlags.NotNull">
            <summary>
            非空
            </summary>
            <remarks>
            序列化引用对象时，默认会先写入一个字节表示该对象是否为空，对于该特性标识的非空对象，不再写入该标识字节
            </remarks>
        </member>
        <member name="F:NewLife.Serialization.Protocol.ConfigFlags.UseRefObject">
            <summary>
            使用引用对象
            </summary>
            <remarks>
            使用引用对象不仅可以避免一个对象因多处引用而序列化多次，还可以避免循环引用
            </remarks>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolEncodeIntAttribute">
            <summary>
            是否使用压缩编码的整数进行序列号
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolEncodeIntAttribute.#ctor(System.Boolean)">
            <summary>
            构造
            </summary>
            <param name="encodeInt"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolEncodeIntAttribute.#ctor">
            <summary>
            构造
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolEncodeIntAttribute.MergeTo(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            已重载。
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolEncodeIntAttribute.Equals(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            已重载。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolEncodeIntAttribute.EncodeInt">
            <summary>是否使用压缩编码整数</summary>
        </member>
        <member name="T:NewLife.Messaging.ExceptionMessage">
            <summary>
            异常消息
            </summary>
        </member>
        <member name="T:NewLife.Messaging.Message">
            <summary>
            消息基类
            </summary>
        </member>
        <member name="T:NewLife.IO.BinaryAccessor">
            <summary>
            二进制数据访问器
            </summary>
        </member>
        <member name="T:NewLife.IO.IBinaryAccessor">
            <summary>
            二进制数据访问器接口，用于把对象数据写入到写入器，或者从读取器中读取数据到对象
            </summary>
        </member>
        <member name="M:NewLife.IO.IBinaryAccessor.Read(NewLife.IO.BinaryReaderX)">
            <summary>
            从读取器中读取数据到对象
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:NewLife.IO.IBinaryAccessor.Write(NewLife.IO.BinaryWriterX)">
            <summary>
            把对象数据写入到写入器
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.Read(NewLife.IO.BinaryReaderX)">
            <summary>
            从读取器中读取数据到对象
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.Read(System.Object,NewLife.IO.BinaryReaderX,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            从读取器中读取数据到对象，指定读取属性还是字段
            </summary>
            <param name="target">目标</param>
            <param name="reader">读取器</param>
            <param name="encodeInt">使用7Bit编码整数</param>
            <param name="allowNull">是否允许对象为空，如果允许，则写入时增加一个字节表示对象是否为空</param>
            <param name="isProperty"></param>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.ReadMember(System.Object,NewLife.IO.BinaryReaderX,NewLife.Reflection.MemberInfoX,System.Boolean,System.Boolean)">
            <summary>
            从读取器中读取数据到对象的成员中
            </summary>
            <param name="target">目标</param>
            <param name="reader">读取器</param>
            <param name="member">成员</param>
            <param name="encodeInt">使用7Bit编码整数</param>
            <param name="allowNull">是否允许对象为空，如果允许，则读取时先读取一个字节判断对象是否为空</param>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.CreateInstance(System.Type)">
            <summary>
            创建指定类型的实例
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.Write(NewLife.IO.BinaryWriterX)">
            <summary>
            把对象数据写入到写入器
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.Write(System.Object,NewLife.IO.BinaryWriterX,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            把指定对象写入到写入器，指定写入属性还是字段
            </summary>
            <param name="target">目标对象</param>
            <param name="writer">写入器</param>
            <param name="encodeInt">使用7Bit编码整数</param>
            <param name="allowNull">是否允许对象为空，如果允许，则写入时增加一个字节表示对象是否为空</param>
            <param name="isProperty"></param>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.WriteMember(System.Object,NewLife.IO.BinaryWriterX,NewLife.Reflection.MemberInfoX,System.Boolean,System.Boolean)">
            <summary>
            把对象成员的数据写入到写入器
            </summary>
            <param name="target">目标对象</param>
            <param name="writer">写入器</param>
            <param name="member">成员</param>
            <param name="encodeInt">使用7Bit编码整数</param>
            <param name="allowNull">是否允许对象为空，如果允许，则写入时增加一个字节表示对象是否为空</param>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.FindFields(System.Type)">
            <summary>
            取得所有可序列化字段
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.FindProperties(System.Type)">
            <summary>
            取得所有属性
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Messaging.Message.StreamHandlerFactoryName">
            <summary>
            数据流工厂名称
            </summary>
        </member>
        <member name="M:NewLife.Messaging.Message.Serialize(System.IO.Stream)">
            <summary>
            序列化当前消息到流中
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Messaging.Message.ToArray">
            <summary>
            序列化为字节数组
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.Deserialize(System.IO.Stream)">
            <summary>
            反序列化
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.RegisterFactory(System.Int32,NewLife.Messaging.IMessageFactory)">
            <summary>
            注册消息工厂，返回原来的消息工厂类型
            </summary>
            <param name="id"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.Create(System.Int32)">
            <summary>
            根据消息编号创建消息实例
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.CreateHandler(System.Int32)">
            <summary>
            根据消息编号创建消息处理器
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.Support(System.Int32)">
            <summary>
            是否支持指定类型的消息
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.Process(System.IO.Stream)">
            <summary>
            处理消息
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Messaging.Message.Process(System.IO.Stream,NewLife.Messaging.MessageExceptionOption)">
            <summary>
            处理消息
            </summary>
            <param name="stream"></param>
            <param name="option"></param>
        </member>
        <member name="M:NewLife.Messaging.Message.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.Message.ID">
            <summary>消息唯一编号</summary>
        </member>
        <member name="E:NewLife.Messaging.Message.Received">
            <summary>
            消息到达时触发
            </summary>
        </member>
        <member name="M:NewLife.Messaging.ExceptionMessage.#ctor(System.Exception)">
            <summary>
            初始化
            </summary>
            <param name="ex"></param>
        </member>
        <member name="P:NewLife.Messaging.ExceptionMessage.ID">
            <summary>
            消息编号
            </summary>
        </member>
        <member name="P:NewLife.Messaging.ExceptionMessage.Error">
            <summary>异常</summary>
        </member>
        <member name="T:NewLife.Collections.SingleListNode`1">
            <summary>
            单向链表节点
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.#ctor(`0)">
            <summary>
            使用一个对象初始化一个节点
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.#ctor(`0,NewLife.Collections.SingleListNode{`0})">
            <summary>
            使用一个对象和下一个节点初始化一个节点
            </summary>
            <param name="item"></param>
            <param name="next"></param>
        </member>
        <member name="P:NewLife.Collections.SingleListNode`1.Item">
            <summary>元素</summary>
        </member>
        <member name="P:NewLife.Collections.SingleListNode`1.Next">
            <summary>下一个节点</summary>
        </member>
        <member name="T:NewLife.Threading.ThreadTask">
            <summary>
            线程任务
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadTask.#ctor(System.Threading.WaitCallback,System.Object)">
            <summary>
            构造一个线程任务
            </summary>
            <param name="method">任务方法</param>
            <param name="argument">任务参数</param>
        </member>
        <member name="M:NewLife.Threading.ThreadTask.#ctor(System.Threading.WaitCallback,System.Threading.WaitCallback,System.Object)">
            <summary>
            构造一个线程任务
            </summary>
            <param name="method">任务方法</param>
            <param name="abortMethod">任务被取消时执行的方法</param>
            <param name="argument">任务参数</param>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.ID">
            <summary>唯一编号</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.Method">
            <summary>任务方法</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.Argument">
            <summary>任务参数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.AbortMethod">
            <summary>取消任务时执行的方法</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.newID">
            <summary>
            取一个新编号
            </summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.WriteContext">
            <summary>
            写入上下文
            </summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ReadWriteContext">
            <summary>
            读写上下文
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ReadWriteContext.Create">
            <summary>
            创建当前对象的新实例
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ReadWriteContext.Clone(System.Object,System.Type,System.Reflection.MemberInfo)">
            <summary>
            使用新参数克隆当前对象
            </summary>
            <param name="data"></param>
            <param name="type"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ReadWriteContext.Clone(System.Object,System.Type,System.Reflection.MemberInfo,System.String)">
            <summary>
            使用新参数克隆当前对象
            </summary>
            <param name="data"></param>
            <param name="type"></param>
            <param name="member"></param>
            <param name="nodeName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ReadWriteContext.GetCustomInterface">
            <summary>
            获取自定义序列化接口，向上递归
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ReadWriteContext.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ReadWriteContext.Formatter">
            <summary>序列化器</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ReadWriteContext.Config">
            <summary>设置</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ReadWriteContext.Node">
            <summary>树形节点</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ReadWriteContext.Data">
            <summary>读写的对象</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ReadWriteContext.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ReadWriteContext.Objects">
            <summary>对象集合。在序列化中，一个对象的多次引用只序列化一份，其它的使用引用计数</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ReadWriteContext.Parent">
            <summary>
            上一级上下文，依赖于Node节点目录树实现
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.WriteContext.Create">
            <summary>
            创建当前对象的新实例
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.WriteContext.Clone(System.Object,System.Type,System.Reflection.MemberInfo)">
            <summary>
            已重载。
            </summary>
            <param name="data"></param>
            <param name="type"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.WriteContext.Writer">
            <summary>写入器</summary>
        </member>
        <member name="T:NewLife.Reflection.FastIndexAccessor">
            <summary>
            快速索引器接口的默认实现
            </summary>
        </member>
        <member name="T:NewLife.Reflection.IIndexAccessor">
            <summary>
            索引器接访问口。
            该接口用于通过名称快速访问对象属性或字段（属性优先）。
            </summary>
        </member>
        <member name="P:NewLife.Reflection.IIndexAccessor.Item(System.String)">
            <summary>
            获取/设置 指定名称的属性或字段的值
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.FastIndexAccessor.Item(System.String)">
            <summary>
            获取/设置 字段值。
            一个索引，反射实现。
            派生实体类可重写该索引，以避免发射带来的性能损耗
            </summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.WeakEventHandler`1">
            <summary>
            弱引用事件
            </summary>
            <remarks>
            很多绑定事件的场合，并不适合取消绑定，这就造成了事件资源无法得到回收。
            更加麻烦的是，事件本身除了包含事件处理方法外，还会包含目标对象，也就导致目标对象无法得到释放。
            弱引用事件的原理是把目标对象与事件处理方法分拆开来，使用弱引用来引用目标对象，保证目标对象能够得到有效的释放。
            触发弱引用事件时，首先判断目标对象是否可用，因为其可能已经被GC回收，然后再通过快速访问方法调用事件处理方法。
            也许有人会问，如果目标对象不可用怎么办？岂不是无法执行事件处理方法了？
            我们换一个角度来看，既然目标对象都已经不存在了，它绑定的事件自然也就无需过问了！
            </remarks>
            <typeparam name="TEventArgs"></typeparam>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Target">
            <summary>
            目标对象。弱引用，使得调用方对象可以被GC回收
            </summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Method">
            <summary>
            委托方法
            </summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Handler">
            <summary>
            经过包装的新的委托
            </summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.UnHandler">
            <summary>
            取消注册的委托
            </summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Once">
            <summary>
            是否只使用一次，如果只使用一次，执行委托后马上取消注册
            </summary>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.#ctor(System.EventHandler{`0},System.Action{System.EventHandler{`0}},System.Boolean)">
            <summary>
            使用事件处理器、取消注册回调、是否一次性事件来初始化
            </summary>
            <param name="handler"></param>
            <param name="unHandler"></param>
            <param name="once"></param>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.Invoke(System.Object,`0)">
            <summary>
            调用委托
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.op_Implicit(NewLife.WeakEventHandler{`0})~System.EventHandler{`0}">
            <summary>
            把弱引用事件处理器转换为普通事件处理器
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.Combine(System.EventHandler{`0}@)">
            <summary>
            绑定
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.Remove(System.EventHandler{`0}@,System.EventHandler{`0})">
            <summary>
            移除
            </summary>
            <param name="handler"></param>
            <param name="value"></param>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolTreeNode">
            <summary>
            协议树节点
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolTreeNode.#ctor(System.String,System.Type)">
            <summary>
            构造
            </summary>
            <param name="name"></param>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolTreeNode.Add(System.String,System.Type)">
            <summary>
            添加
            </summary>
            <param name="name"></param>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolTreeNode.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTreeNode.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTreeNode.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTreeNode.Depth">
            <summary>深度</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTreeNode.Parent">
            <summary>父亲节点</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTreeNode.Context">
            <summary>上下文</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTreeNode.Nodes">
            <summary>子节点</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTreeNode.Path">
            <summary>
            路径
            </summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolTreeNode.Top">
            <summary>
            顶级节点
            </summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolSerialPropertyAttribute">
            <summary>
            是否把属性作为主要序列化对象
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolSerialPropertyAttribute.#ctor(System.Boolean)">
            <summary>
            构造
            </summary>
            <param name="serialProperty"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolSerialPropertyAttribute.#ctor">
            <summary>
            构造
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolSerialPropertyAttribute.MergeTo(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            已重载。
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolSerialPropertyAttribute.Equals(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            已重载。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolSerialPropertyAttribute.SerialProperty">
            <summary>
            序列化属性
            </summary>
            <remarks>
            默认情况下只序列化字段，但是由特性控制的是否序列化优先级更高，该标识仅对没有任何特性的字段或属性有效
            </remarks>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolArrayAttribute">
            <summary>
            协议数组元素
            </summary>
            <remarks>
            该特性仅对数据及实现了IEnumerable接口的字段或属性有效
            </remarks>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolArrayAttribute.#ctor(System.Int32)">
            <summary>
            构造
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolArrayAttribute.MergeTo(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            已重载。
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolArrayAttribute.Equals(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            已重载。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolArrayAttribute.Size">
            <summary>大小</summary>
            <remarks>默认为0时，首先序列化一个压缩整数作为数组元素个数，再序列化每一个项；设置了大小后，不再压缩元素个数，而是以特性指定的大小为准</remarks>
        </member>
        <member name="T:NewLife.Collections.InterlockedStack`1">
            <summary>
            先进先出FIFO的原子锁栈结构，采用CAS保证线程安全。
            </summary>
            <remarks>
            经过测试，对象数量在万级以上时，性能急剧下降！
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:NewLife.Collections.InterlockedStack`1.Top">
            <summary>
            栈顶
            </summary>
        </member>
        <member name="F:NewLife.Collections.InterlockedStack`1._version">
            <summary>
            版本
            </summary>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Push(`0)">
            <summary>
            向栈压入一个对象
            </summary>
            <remarks>重点解决多线程环境下资源争夺以及使用lock造成性能损失的问题</remarks>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Pop">
            <summary>
            从栈中弹出一个对象
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.TryPop(`0@)">
            <summary>
            尝试从栈中弹出一个对象
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Peek">
            <summary>
            获取栈顶对象，不弹栈
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.TryPeek(`0@)">
            <summary>
            尝试获取栈顶对象，不弹栈
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Clear">
            <summary>
            清空
            </summary>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.ToArray">
            <summary>
            转为数组
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.GetEnumerator">
            <summary>
            获取枚举器
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.InterlockedStack`1.Count">
            <summary>元素个数</summary>
        </member>
        <member name="T:NewLife.Collections.InterlockedStack`1.Enumerator">
            <summary>
            原子栈枚举器
            </summary>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Enumerator.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Enumerator.MoveNext">
            <summary>
            移到下一个
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.InterlockedStack`1.Enumerator.Current">
            <summary>
            当前对象
            </summary>
        </member>
        <member name="T:NewLife.Collections.ObjectPool`1">
            <summary>
            对象池
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Push(`0)">
            <summary>
            归还
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Pop">
            <summary>
            借出
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Create">
            <summary>
            创建实例
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Clear">
            <summary>
            清空
            </summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnDispose(System.Boolean)">
            <summary>
            子类重载实现资源释放逻辑
            </summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Stock">
            <summary>在库</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.StockCount">
            <summary>在库</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.NotStockCount">
            <summary>不在库</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.CreateCount">
            <summary>创建数</summary>
        </member>
        <member name="T:NewLife.Messaging.IMessageFactory">
            <summary>
            消息工厂接口，用于创建信息实例和消息处理器
            </summary>
        </member>
        <member name="M:NewLife.Messaging.IMessageFactory.Create(System.Int32)">
            <summary>
            创建指定编号的消息
            </summary>
            <param name="messageID"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.IMessageFactory.CreateHandler(System.Int32)">
            <summary>
            创建消息处理器
            </summary>
            <param name="messageID"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.WeakReference`1">
            <summary>
            弱引用
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.WeakReference`1.#ctor">
            <summary>
            实例化
            </summary>
        </member>
        <member name="M:NewLife.WeakReference`1.#ctor(`0)">
            <summary>
            实例化
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:NewLife.WeakReference`1.#ctor(`0,System.Boolean)">
            <summary>
            实例化
            </summary>
            <param name="target"></param>
            <param name="trackResurrection"></param>
        </member>
        <member name="M:NewLife.WeakReference`1.op_Implicit(NewLife.WeakReference{`0})~`0">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.WeakReference`1.op_Implicit(`0)~NewLife.WeakReference{`0}">
            <summary>
            类型转换
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.WeakReference`1.Target">
            <summary>
            目标引用对象
            </summary>
        </member>
        <member name="T:NewLife.IO.ReadWriteStream">
            <summary>
            读写流。读写不在一起。
            </summary>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.#ctor(System.IO.Stream,System.IO.Stream)">
            <summary>
            初始化
            </summary>
            <param name="inputStream"></param>
            <param name="outputStream"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Flush">
            <summary>
            刷新输出流写入的数据
            </summary>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从输入流中读取数据
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            在输入流中搜索
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.SetLength(System.Int64)">
            <summary>
            设置输出流的长度
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            把数据写入到输出流中
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Peek">
            <summary>
            读取一个字节，不移动指针
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.InputStream">
            <summary>输入流</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.OutputStream">
            <summary>输出流</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.CanRead">
            <summary>
            输入流是否可读
            </summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.CanSeek">
            <summary>
            输入流是否可移动
            </summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.CanWrite">
            <summary>
            输出流是否可写
            </summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.Length">
            <summary>
            输入流总长度
            </summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.Position">
            <summary>
            输入流位置
            </summary>
        </member>
        <member name="T:NewLife.Log.WriteLogEventArgs">
            <summary>
            写日志事件参数
            </summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message">日志</param>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message">日志</param>
            <param name="exception">异常</param>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Message">
            <summary>日志信息</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Exception">
            <summary>异常</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Time">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadID">
            <summary>线程编号</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.IsPoolThread">
            <summary>是否线程池线程</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadName">
            <summary>线程名</summary>
        </member>
        <member name="T:NewLife.IO.BinaryWriterX">
            <summary>
            二进制协议写入器
            </summary>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.#ctor(System.IO.Stream)">
            <summary>
            构造
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteEncoded(System.Int32)">
            <summary>
            以压缩格式写入32位整数
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteEncoded(System.Int64)">
            <summary>
            以压缩格式写入64位整数
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteValue(System.Object,System.Boolean)">
            <summary>
            写入值类型，只能识别基础类型，对于不能识别的类型，方法返回false
            </summary>
            <param name="value"></param>
            <param name="encodeInt">是否编码整数</param>
            <returns>是否成功写入</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteX(System.Object)">
            <summary>
            扩展写入，反射查找合适的写入方法
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.Write(System.Guid)">
            <summary>
            写入Guid
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.Write(System.Net.IPAddress)">
            <summary>
            写入IPAddress
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.Write(System.Net.IPEndPoint)">
            <summary>
            写入IPEndPoint
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:NewLife.EventArgs`1">
            <summary>
            泛型事件参数
            </summary>
            <typeparam name="TArg"></typeparam>
        </member>
        <member name="M:NewLife.EventArgs`1.#ctor(`0)">
            <summary>
            使用参数初始化
            </summary>
            <param name="arg"></param>
        </member>
        <member name="P:NewLife.EventArgs`1.Arg">
            <summary>参数</summary>
        </member>
        <member name="T:NewLife.EventArgs`2">
            <summary>
            泛型事件参数
            </summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
        </member>
        <member name="M:NewLife.EventArgs`2.#ctor(`0,`1)">
            <summary>
            使用参数初始化
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="T:NewLife.EventArgs`3">
            <summary>
            泛型事件参数
            </summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
        </member>
        <member name="M:NewLife.EventArgs`3.#ctor(`0,`1,`2)">
            <summary>
            使用参数初始化
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg3">
            <summary>参数3</summary>
        </member>
        <member name="T:NewLife.Threading.ThreadPoolX">
            <summary>
            线程池。所有静态方法和实例方法均是线程安全。
            </summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX.SynLock_mt">
            <summary>
            用于维护管理线程的锁
            </summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX._ManagerThread">
            <summary>
            使用volatile关键字，等到对象创建完成
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Init">
            <summary>
            第一个任务到来时初始化线程池
            </summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX.SyncLock_Threads">
            <summary>
            用户维护线程组的锁
            </summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX.Sync_Tasks">
            <summary>
            任务队列同步锁
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.#ctor(System.String)">
            <summary>
            构造一个线程池
            </summary>
            <param name="name">线程池名</param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Create(System.String)">
            <summary>
            创建线程池。一个名字只能创建一个线程池。线程安全。
            </summary>
            <param name="name">线程池名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(System.Threading.WaitCallback)">
            <summary>
            把用户工作项放入队列
            </summary>
            <param name="method">任务方法</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(System.Threading.WaitCallback,System.Object)">
            <summary>
            把用户工作项放入队列
            </summary>
            <param name="method">任务方法</param>
            <param name="argument">任务参数</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(System.Threading.WaitCallback,System.Threading.WaitCallback,System.Object)">
            <summary>
            把用户工作项放入队列。指定任务被取消时执行的方法，该方法仅针对尚未被线程开始调用时的任务有效
            </summary>
            <param name="method">任务方法</param>
            <param name="abortMethod">任务被取消时执行的方法</param>
            <param name="argument">任务参数</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(NewLife.Threading.ThreadTask)">
            <summary>
            把用户工作项放入队列
            </summary>
            <param name="task">任务</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Abort(System.Int32)">
            <summary>
            取消任务
            </summary>
            <param name="id">任务编号</param>
            <returns>任务状态</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AbortAllTask">
            <summary>
            取消所有未开始任务
            </summary>
            <remarks>这里不要调用上面Abort取消单个任务，否则可能会造成死锁</remarks>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AbortAllThread">
            <summary>
            取消所有进行中任务
            </summary>
            <remarks>这里不要调用上面Abort取消单个任务，否则可能会造成死锁</remarks>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AbortAll">
            <summary>
            取消所有任务
            </summary>
            <remarks>这里不要调用上面Abort取消单个任务，否则可能会造成死锁</remarks>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Query(System.Int32)">
            <summary>
            查询任务状态
            </summary>
            <param name="id">任务编号</param>
            <returns>任务状态</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueryCount">
            <summary>
            查询任务个数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.WaitAll(System.Int32)">
            <summary>
            等待所有任务完成，并指定是否在等待之前退出同步域。
            </summary>
            <param name="millisecondsTimeout"></param>
            <returns>是否在等待之前退出同步域</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Work">
            <summary>
            调度包装
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AddThread">
            <summary>
            添加线程。本方法不是线程安全，调用者需要自己维护线程安全
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Open">
            <summary>
            借用线程
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Close(NewLife.Threading.ThreadX)">
            <summary>
            归还线程
            </summary>
            <param name="thread"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Finalize">
            <summary>
            析构
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.MaxThreads">
            <summary>最大线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.MinThreads">
            <summary>最小线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Name">
            <summary>线程池名称</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.LastError">
            <summary>最后的异常</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.ManagerThread">
            <summary>维护线程</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Threads">
            <summary>线程组。适用该资源时，记得加上线程锁lockObj</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.ThreadCount">
            <summary>当前线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.RunningCount">
            <summary>正在处理任务的线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Event">
            <summary>事件量</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Tasks">
            <summary>任务队列</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Debug">
            <summary>
            是否调试
            </summary>
        </member>
        <member name="T:NewLife.Reflection.Func">
            <summary>
            没有参数和返回值的委托
            </summary>
        </member>
        <member name="T:NewLife.Reflection.Func`1">
            <summary>
            具有指定类型返回的委托
            </summary>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`2">
            <summary>
            具有指定参数和返回的委托
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`3">
            <summary>
            具有指定两个参数和返回的委托
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`4">
            <summary>
            具有指定三个参数和返回的委托
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`5">
            <summary>
            具有指定四个参数和返回的委托
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`6">
            <summary>
            具有指定五个参数和返回的委托
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <param name="arg5"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolSerializedEventArgs">
            <summary>
            协议序列化事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolSerializedEventArgs.#ctor(NewLife.Serialization.Protocol.WriteContext)">
            <summary>
            构造
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolSerializedEventArgs.Context">
            <summary>上下文</summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolDeserializedEventArgs">
            <summary>
            协议反序列化事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolDeserializedEventArgs.#ctor(NewLife.Serialization.Protocol.ReadContext)">
            <summary>
            构造
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolDeserializedEventArgs.Context">
            <summary>上下文</summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolNotNullAttribute">
            <summary>
            是否不为空
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolNotNullAttribute.#ctor(System.Boolean)">
            <summary>
            构造
            </summary>
            <param name="notNull"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolNotNullAttribute.#ctor">
            <summary>
            构造
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolNotNullAttribute.MergeTo(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            已重载。
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolNotNullAttribute.Equals(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            已重载。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolNotNullAttribute.NotNull">
            <summary>是否不为空</summary>
            <remarks>序列化引用对象时，默认会先写入一个字节表示该对象是否为空，对于该特性标识的非空对象，不再写入该标识字节</remarks>
        </member>
        <member name="T:NewLife.IO.IStreamHandler">
            <summary>
            数据流处理器接口
            </summary>
        </member>
        <member name="M:NewLife.IO.IStreamHandler.Process(System.IO.Stream)">
            <summary>
            处理数据流
            </summary>
            <param name="stream"></param>
        </member>
        <member name="P:NewLife.IO.IStreamHandler.IsReusable">
            <summary>
            是否可以重用
            </summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolFormatter">
            <summary>
            协议序列化
            </summary>
            <remarks>
            协议序列化分为两大类：
            1，纯数据不包含头部的协议类型序列化；
            2，包含头部信息的增强型序列化。
            而不管是哪一类序列化，都将以最小序列化结果作为目标。
            </remarks>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.#ctor">
            <summary>
            构造
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.#ctor(System.Type)">
            <summary>
            构造
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.WriteMember(NewLife.Serialization.Protocol.WriteContext)">
            <summary>
            写入对象
            </summary>
            <remarks>
            分为几种情况：
            1，空引用直接写入0
            2，基本值类型直接写入值
            3，非基本值类型先查找是否已有引用，已有则写入引用计数（从1开始，因为0表示空引用），没有则添加到引用集合，不写引用计数
            4，数组和枚举类型先写入元素个数，再依次写入元素
            5，对象类型，反射得到属性和字段，一个个写入
            值得注意的是，数据和枚举本也使用引用计数防止重复引用，同时包含引用计数和元素个数
            </remarks>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.ReadMember(NewLife.Serialization.Protocol.ReadContext)">
            <summary>
            读取对象
            </summary>
            <remarks>
            非对象类型直接返回数据；
            对象类型且参数context.Data不为空时，填充context.Data；
            对象类型且参数context.Data为空时，创建对象，填充后返回
            </remarks>
            <remarks>
            分为几种情况：
            1，空引用直接写入0
            2，基本值类型直接写入值
            3，非基本值类型先查找是否已有引用，已有则写入引用计数（从1开始，因为0表示空引用），没有则添加到引用集合，再写入引用计数
            4，数组和枚举类型先写入元素个数，再依次写入元素
            5，对象类型，反射得到属性和字段，一个个写入
            值得注意的是，数据和枚举本也使用引用计数防止重复引用，同时包含引用计数和元素个数
            </remarks>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.Serialize(System.IO.Stream,System.Object)">
            <summary>
            把一个对象序列化到指定流中
            </summary>
            <param name="stream"></param>
            <param name="obj"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.Deserialize(System.IO.Stream)">
            <summary>
            从指定流中读取一个对象
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.Deserialize(System.IO.Stream,System.Object)">
            <summary>
            从指定流读取数据填充到指定对象
            </summary>
            <param name="stream"></param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.FindAllSerialized(System.Type,System.Boolean)">
            <summary>
            获取所有可序列化的字段
            </summary>
            <param name="type"></param>
            <param name="serialProperty">主要序列化属性，没有标记的属性全部返回，否则仅返回标记了协议特性的属性</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.OnSerializing(NewLife.Serialization.Protocol.WriteContext)">
            <summary>
            序列化前触发
            </summary>
            <param name="context"></param>
            <returns>是否允许序列化当前字段或属性</returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.OnSerialized(NewLife.Serialization.Protocol.WriteContext)">
            <summary>
            序列化后触发
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.OnDeserializing(NewLife.Serialization.Protocol.ReadContext)">
            <summary>
            反序列化前触发
            </summary>
            <param name="context"></param>
            <returns>是否允许反序列化当前字段或属性</returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.OnDeserialized(NewLife.Serialization.Protocol.ReadContext)">
            <summary>
            反序列化后触发
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolFormatter.OnCreateInstance(NewLife.Serialization.Protocol.ReadContext,System.Type)">
            <summary>
            为指定类型创建实例时触发
            </summary>
            <remarks>当内部自定义后外部事件同时存在时，优先外部事件</remarks>
            <param name="context"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatter.Head">
            <summary>头部</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatter.Binder">
            <summary>绑定器</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatter.Context">
            <summary>上下文</summary>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolFormatter.SurrogateSelector">
            <summary></summary>
        </member>
        <member name="E:NewLife.Serialization.Protocol.ProtocolFormatter.Serializing">
            <summary>
            序列化前
            </summary>
        </member>
        <member name="E:NewLife.Serialization.Protocol.ProtocolFormatter.Serialized">
            <summary>
            序列化后
            </summary>
        </member>
        <member name="E:NewLife.Serialization.Protocol.ProtocolFormatter.Deserializing">
            <summary>
            反序列化前
            </summary>
        </member>
        <member name="E:NewLife.Serialization.Protocol.ProtocolFormatter.Deserialized">
            <summary>
            反序列化后
            </summary>
        </member>
        <member name="E:NewLife.Serialization.Protocol.ProtocolFormatter.CreateInstance">
            <summary>
            创建实例
            </summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ReadContext">
            <summary>
            读取上下文
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ReadContext.Create">
            <summary>
            创建当前对象的新实例
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ReadContext.Clone(System.Object,System.Type,System.Reflection.MemberInfo)">
            <summary>
            已重载。
            </summary>
            <param name="data"></param>
            <param name="type"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ReadContext.Reader">
            <summary>读取器</summary>
        </member>
        <member name="T:NewLife.IO.StreamHttpHandler">
            <summary>
            数据流Http处理器。可以在web.config中配置一个处理器指向该类。
            </summary>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            处理请求
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:NewLife.IO.StreamHttpHandler.IsReusable">
            <summary>
            是否可以重用
            </summary>
        </member>
        <member name="T:NewLife.Reflection.MethodInfoX">
            <summary>
            快速调用。基于DynamicMethod和Emit实现。
            </summary>
        </member>
        <member name="T:NewLife.Reflection.MemberInfoX">
            <summary>
            快速访问成员
            </summary>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.#ctor(System.Reflection.MemberInfo)">
            <summary>
            初始化
            </summary>
            <param name="member"></param>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.Invoke(System.Object,System.Object[])">
            <summary>
            执行方法
            </summary>
            <param name="obj"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.GetValue(System.Object)">
            <summary>
            取值
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.SetValue(System.Object,System.Object)">
            <summary>
            赋值
            </summary>
            <param name="obj"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.op_Implicit(NewLife.Reflection.MemberInfoX)~System.Reflection.MemberInfo">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.op_Implicit(System.Reflection.MemberInfo)~NewLife.Reflection.MemberInfoX">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Type">
            <summary>
            成员类型
            </summary>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Create(System.Reflection.MethodInfo)">
            <summary>
            创建
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Create(System.Type,System.String)">
            <summary>
            创建
            </summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Invoke(System.Object,System.Object[])">
            <summary>
            参数调用
            </summary>
            <param name="obj"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.op_Implicit(NewLife.Reflection.MethodInfoX)~System.Reflection.MethodInfo">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.op_Implicit(System.Reflection.MethodInfo)~NewLife.Reflection.MethodInfoX">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.MethodInfoX.Method">
            <summary>目标方法</summary>
        </member>
        <member name="T:NewLife.Reflection.MethodInfoX.FastInvokeHandler">
            <summary>
            快速调用委托
            </summary>
            <param name="obj"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.PropertyInfoX">
            <summary>
            快速属性访问
            </summary>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.Create(System.Reflection.PropertyInfo)">
            <summary>
            创建
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.Create(System.Type,System.String)">
            <summary>
            创建
            </summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.GetValue(System.Object)">
            <summary>
            取值
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.SetValue(System.Object,System.Object)">
            <summary>
            赋值
            </summary>
            <param name="obj"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.op_Implicit(NewLife.Reflection.PropertyInfoX)~System.Reflection.PropertyInfo">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.op_Implicit(System.Reflection.PropertyInfo)~NewLife.Reflection.PropertyInfoX">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.PropertyInfoX.Property">
            <summary>目标属性</summary>
        </member>
        <member name="T:NewLife.Web.HttpStream">
            <summary>
            HTTP输入输出流
            </summary>
        </member>
        <member name="M:NewLife.Web.HttpStream.#ctor(System.Web.HttpContext)">
            <summary>
            初始化
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Web.HttpStream.Flush">
            <summary>
            已重载。
            </summary>
        </member>
        <member name="P:NewLife.Web.HttpStream.Context">
            <summary>HTTP上下文</summary>
        </member>
        <member name="T:NewLife.Threading.TaskState">
            <summary>
            任务状态
            </summary>
        </member>
        <member name="F:NewLife.Threading.TaskState.Unstarted">
            <summary>
            未处理
            </summary>
        </member>
        <member name="F:NewLife.Threading.TaskState.Running">
            <summary>
            正在处理
            </summary>
        </member>
        <member name="F:NewLife.Threading.TaskState.Finished">
            <summary>
            已完成
            </summary>
        </member>
        <member name="T:NewLife.Messaging.MessageStreamHandler">
            <summary>
            用于消息的数据流处理器。
            </summary>
        </member>
        <member name="T:NewLife.Messaging.MessageStreamHandlerFactory">
            <summary>
            用于消息的数据流处理器工厂
            </summary>
        </member>
        <member name="T:NewLife.IO.StreamHandlerFactory">
            <summary>
            数据流处理器工厂
            </summary>
        </member>
        <member name="T:NewLife.IO.IStreamHandlerFactory">
            <summary>
            数据流处理器工厂接口
            </summary>
        </member>
        <member name="M:NewLife.IO.IStreamHandlerFactory.GetHandler(System.IO.Stream)">
            <summary>
            获取处理器
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHandlerFactory.GetHandler(System.IO.Stream)">
            <summary>
            获取处理器
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHandlerFactory.RegisterFactory(System.String,NewLife.IO.IStreamHandlerFactory)">
            <summary>
            注册数据流处理器工厂。
            数据流到达时将进入指定通道的每一个工厂，直到工厂可以返回数据流处理器为止。
            不同通道名称的工厂互不干扰。
            </summary>
            <param name="name">通道名称，用于区分数据流总线</param>
            <param name="factory"></param>
        </member>
        <member name="M:NewLife.IO.StreamHandlerFactory.GetFactory">
            <summary>
            获取配置文件指定的工厂
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHandlerFactory.LoadConfig">
            <summary>
            从配置文件中加载工厂
            </summary>
        </member>
        <member name="M:NewLife.IO.StreamHandlerFactory.Process(System.String,System.IO.Stream)">
            <summary>
            处理数据流。Http、Tcp、Udp等所有数据流都将到达这里，多种传输方式汇聚于此，由数据流总线统一处理！
            </summary>
            <param name="name"></param>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Messaging.MessageStreamHandlerFactory.GetHandler(System.IO.Stream)">
            <summary>
            返回消息的数据流处理器。所有数据流都会到达这里，所以这里需要区分哪些是需要自己来处理的。
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolDeserializingEventArgs">
            <summary>
            协议反序列化事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolDeserializingEventArgs.#ctor(NewLife.Serialization.Protocol.ReadContext)">
            <summary>
            构造
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolDeserializingEventArgs.Context">
            <summary>上下文</summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolUseRefObjectAttribute">
            <summary>
            是否使用对象引用
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolUseRefObjectAttribute.#ctor(System.Boolean)">
            <summary>
            构造
            </summary>
            <param name="useRefObject"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolUseRefObjectAttribute.#ctor">
            <summary>
            构造
            </summary>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolUseRefObjectAttribute.MergeTo(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            已重载。
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Serialization.Protocol.ProtocolUseRefObjectAttribute.Equals(NewLife.Serialization.Protocol.FormatterConfig)">
            <summary>
            已重载。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.Protocol.ProtocolUseRefObjectAttribute.UseRefObject">
            <summary>是否使用对象引用</summary>
        </member>
        <member name="T:NewLife.Collections.DictionaryCache`2">
            <summary>
            字典缓存
            </summary>
            <typeparam name="TKey">键类型</typeparam>
            <typeparam name="TValue">值类型</typeparam>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem(`0,NewLife.Reflection.Func{`0,`1})">
            <summary>
            扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。
            </summary>
            <param name="key"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``1(`0,``0,NewLife.Reflection.Func{`0,``0,`1})">
            <summary>
            扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。
            </summary>
            <typeparam name="TArgs">参数类型</typeparam>
            <param name="key"></param>
            <param name="args"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Threading.ThreadX">
            <summary>
            线程扩展
            </summary>
        </member>
        <member name="F:NewLife.Threading.ThreadX.internalEvent">
            <summary>
            内部控制事件
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Start">
            <summary>
            开始
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Abort(System.Boolean)">
            <summary>
            取消
            </summary>
            <param name="onlytask">是否仅仅取消任务</param>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Dispose(System.Boolean)">
            <summary>
            释放资源。非用户代码调用时，仅释放非托管资源
            </summary>
            <param name="disposing">是否用户代码调用</param>
        </member>
        <member name="M:NewLife.Threading.ThreadX.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadX.FindException``1(System.Exception)">
            <summary>
            查找指定类型的异常
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Task">
            <summary>任务</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.LastError">
            <summary>最后错误</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Running">
            <summary>是否正在处理任务</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.IsAlive">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.CanRelease">
            <summary>
            是否能够释放
            </summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Thread">
            <summary>线程</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.StartTime">
            <summary>开始时间</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.AliveTime">
            <summary>活动时间</summary>
        </member>
        <member name="E:NewLife.Threading.ThreadX.OnTaskFinished">
            <summary>任务完成时</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Debug">
            <summary>
            是否调试
            </summary>
        </member>
        <member name="T:NewLife.Serialization.Protocol.ProtocolElementAttribute">
            <summary>
            协议元素特性
            </summary>
            <remarks>
            设置了该特性的字段或属性一定会被序列化
            </remarks>
        </member>
        <member name="T:NewLife.Reflection.FieldInfoX">
            <summary>
            快速字段访问
            </summary>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.Create(System.Reflection.FieldInfo)">
            <summary>
            创建
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.Create(System.Type,System.String)">
            <summary>
            创建
            </summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.GetValue(System.Object)">
            <summary>
            取值
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.SetValue(System.Object,System.Object)">
            <summary>
            赋值
            </summary>
            <param name="obj"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.op_Implicit(NewLife.Reflection.FieldInfoX)~System.Reflection.FieldInfo">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.op_Implicit(System.Reflection.FieldInfo)~NewLife.Reflection.FieldInfoX">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.FieldInfoX.Field">
            <summary>目标字段</summary>
        </member>
        <member name="T:NewLife.IO.ReadWriteMemoryStream">
            <summary>
            读写流，继承自内存流，读写指针分开
            </summary>
            <remarks>
            注意资源锁，读写不可同时进行，会出现抢锁的情况。
            </remarks>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.SeekForWrite(System.Int64,System.IO.SeekOrigin)">
            <summary>
            已重载。
            </summary>
            <param name="offset"></param>
            <param name="loc"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.ResetLength">
            <summary>
            重设长度，
            </summary>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            已重载。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.ReadByte">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            已重载。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.WriteByte(System.Byte)">
            <summary>
            已重载。
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.Dispose(System.Boolean)">
            <summary>
            资源释放，关闭事件量
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.ReadTimeout">
            <summary>获取或设置一个值（以毫秒为单位），该值确定流在超时前尝试读取多长时间。</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.PositionForWrite">
            <summary>写位置</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.MaxLength">
            <summary>最大长度，超过次长度时清空缓冲区</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.AvailableData">
            <summary>可用数据</summary>
        </member>
        <member name="T:NewLife.Messaging.IMessageHandler">
            <summary>
            消息处理器
            </summary>
        </member>
        <member name="M:NewLife.Messaging.IMessageHandler.Process(NewLife.Messaging.Message,System.IO.Stream)">
            <summary>
            处理消息
            </summary>
            <param name="message">消息</param>
            <param name="stream">数据流，已经从里面读取消息实体</param>
        </member>
        <member name="T:NewLife.Reflection.ReadWriteLock">
            <summary>
            原子读写锁
            </summary>
            <remark>
            任意多个读操作，只有一个写操作；
            任意读操作阻塞写操作，同样任意写操作阻塞非本线程读操作和其它写操作；
            </remark>
            <remarks>
            do...while(Interlocked.CompareExchange(ref _lock, oldLock - 1, oldLock) != oldLock)形式的原子锁结构，
            精髓在于do...while之间，里面才是真正的判断数据有效性核心，而CompareExchange仅仅是负责完成替换而已。
            实际上，就类似于准备好各种资料等上级审批，而上级每次只能审批一个，如果这次别人抢到了，那么自己得再次准备资料。
            </remarks>
        </member>
        <member name="F:NewLife.Reflection.ReadWriteLock._lock">
            <summary>
            锁计数
            </summary>
        </member>
        <member name="F:NewLife.Reflection.ReadWriteLock._threadID">
            <summary>
            写入线程的ID。用于多次调用识别
            </summary>
        </member>
        <member name="F:NewLife.Reflection.ReadWriteLock._recursionCount">
            <summary>
            循环计数。多次调用时，实现递加或递减
            </summary>
        </member>
        <member name="M:NewLife.Reflection.ReadWriteLock.Create(System.Object)">
            <summary>
            根据指定键值创建读写锁，一般读写锁需要针对指定资源唯一
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ReadWriteLock.AcquireRead">
            <summary>
            请求读取锁
            </summary>
        </member>
        <member name="M:NewLife.Reflection.ReadWriteLock.ReleaseRead">
            <summary>
            释放读取锁
            </summary>
        </member>
        <member name="M:NewLife.Reflection.ReadWriteLock.AcquireWrite">
            <summary>
            请求写入锁
            </summary>
        </member>
        <member name="M:NewLife.Reflection.ReadWriteLock.ReleaseWrite">
            <summary>
            释放写入锁
            </summary>
        </member>
        <member name="T:NewLife.WeakAction`1">
            <summary>
            弱引用Action
            </summary>
            <typeparam name="TArgs"></typeparam>
        </member>
        <member name="F:NewLife.WeakAction`1.Target">
            <summary>
            目标对象。弱引用，使得调用方对象可以被GC回收
            </summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Method">
            <summary>
            委托方法
            </summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Handler">
            <summary>
            经过包装的新的委托
            </summary>
        </member>
        <member name="F:NewLife.WeakAction`1.UnHandler">
            <summary>
            取消注册的委托
            </summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Once">
            <summary>
            是否只使用一次，如果只使用一次，执行委托后马上取消注册
            </summary>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Action{`0},System.Action{System.Action{`0}},System.Boolean)">
            <summary>
            使用事件处理器、取消注册回调、是否一次性事件来初始化
            </summary>
            <param name="handler"></param>
            <param name="unHandler"></param>
            <param name="once"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.Invoke(`0)">
            <summary>
            调用委托
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.op_Implicit(NewLife.WeakAction{`0})~System.Action{`0}">
            <summary>
            把弱引用事件处理器转换为普通事件处理器
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
    </members>
</doc>
